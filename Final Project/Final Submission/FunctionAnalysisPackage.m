(* ::Package:: *)

BeginPackage["FunctionAnalysis`"]

DPConvertDoc::usage = "DPConvertDoc[function_String, levelOfExample_String], returns a list of all examples with HoldComplete"
DPOptionQ::usage = "DPOptionQ[function_String], returns true is functionName is an option"
DPIsOptionOfQ::usage = "DPIsOptionOfQ[function_String, option_String], return true if option is an option of function"

(* PLEASE USE HOLDCOMPLETE FOR PASSING EXPRESSIONS TO THESE FUNCTIONS!*) 

FCCounter::usage = "FCCounter[input___, head_String], counts any function that appears in input and removes head from the count"
FCCounterNoOptions::usage = "FCCounterNoOptions[input___, head_String], same as FCCounter but removes options if they are not associated with head"
FCFrequencyList::usage = "FCFrequencyList[functions_List, level_String], parse the documentation for all function names in functions and take examples at level"
FCGenerateGraph::usage = ""
FCGenerateWeights::usage = ""

FAGenerateAssociation::usage = "Generate an association of all symbols with all symbols"
FATreePos::usage = "FATreePos[expr, lvl_List], gives the tree of all functions"
FAFindHeads::usage = "FAFindHeads[treePos], takes a tree generated by FATreePos and gives the position of all heads"
FAFindChildren::usage = "FAFindChildren[parent, treePos], takes a position and all positions generated by FATreePos and gives the children of the position"
FAExtractWName::usage = "FAExtractWName[expr], gives all functions in expr and their parenty link"
FAExtractAndApplyTo::usage = "FAExtractAndApplyTo[association, expr], takes an association generated by FAGenerateAssociation and count all functions"
FAExtractWCount::usage = "FAExtractWCount[expr_], takes an expression and gives the count of all functions that appear"

FAGenerateGraph::usage = "FAGenerateGraph[association, directed_Boolean], generate a graph from the association with the choice for a directed or undirected graph"
FAGenerateWeights::usage = "FAGenerateWeights[g_Graph, association, (formula)], generate a list of all the weights using formula (user defined function), if not formula is provided the default one will apply"
FAFindCommonWith::usage = "FAFindCommonWith[func_String, weights_, association], find the most common functions used with func"
FAGenerateGraphFromInput::usage = "FAGenerateGraphFromInput[input_, directed], generates a graph from the input, directed or not"
FAFindAllCommon::usage = "FAFindAllCommon[input_], returns an association of all symbols with their function commonly used with in the input"

Begin["`Private`"]

(* --- Counting arguments of funtions, better analysis --- *)

    (* fullAssociation = FAGenerateAssociation[]; *)

SetAttributes[{FATreePos, FAFindChildren, FAFindHeads, FAExtractWName, FAExtractAndApplyTo, FAExtractWCount, FAGenerateGraphFromInput}, HoldAllComplete];

FAGenerateAssociation[] := AssociationThread[Names["System`*" ],  AssociationThread[Names["System`*"], ConstantArray[0, Length[Names["System`*"]]]]]  

FATreePos[expr_, lvl_List] := Position[expr, s_Symbol /; Context[Unevaluated[s]]=="System`",lvl,Heads->True]
FATreePos[expr_] := FATreePos[expr, {2, Infinity}]

FAFindHeads[treePos_] := Cases[treePos, {___, 0}]
FAFindChildren[{parent___, 0}, treePos_] := Cases[treePos, {parent, Except[0]} | {parent, Except[0], 0}]

FAExtractWName[func_] := 
    Block[
        {tree = FATreePos[func], heads, tmp}, 
        heads = FAFindHeads[tree];
        tmp = Thread[tree -> ToString /@ Extract[func, tree, HoldForm]];
        Merge[Thread[Lookup[tmp, heads] -> Map[Lookup[tmp, FAFindChildren[#, tree]]&, heads]], Identity]
    ]

FAExtractWCount[func_] := Map[Counts, Flatten /@ FAExtractWName[func]]

SetAttributes[FAExtractAndApplyTo, HoldFirst];
FAExtractAndApplyTo[association_, func_] /; AssociationQ[association] := 
    Block[
        {data = FAExtractWCount[func]},
        Scan[Function[n1, Scan[Function[n2,  association[n1][n2] += data[n1][n2]], Keys @ data[n1]]], Keys @ data];
    ]

(* Graph related functions*)

FAGenerateGraph[association_Association, directed_?BooleanQ] := 
    AdjacencyGraph[
        Keys @ association, 
        Values @ Values @ association, 
        DirectedEdges->directed,
        VertexLabels->Placed[Automatic, Tooltip]
    ]



WeightFunction[x_] := 1/(Log[x]+1)  
FAGenerateWeights[g_Graph, association_Association] := FAGenerateWeights[g, association, WeightFunction]
FAGenerateWeights[g_Graph, association_Association, formula_] := 
    AssociationThread[
        Keys @ association, 
        formula[VertexDegree[g]]
    ]

FAFindCommonWith[func_String, weights_, association_Association] :=
    Block [
        {weighted = Map[association[func][#] * weights[#] &, Keys @ association[func]]},
        Select[AssociationThread[Keys @ association[func], weighted], # > 0 &]
    ]
FAFindCommonWith[func_String, g_Graph, association_Association] := FAFindCommonWith[func, FAGenerateWeights[g, association], association]
FAFindCommonWith[func_String, input_] := 
    Block [
        {
            fa = FAGenerateAssociation[],
            g
        },
        FAExtractAndApplyTo[fa, input];
        g = FAGenerateGraph[fa, True];
        FAFindCommonWith[func, g, fa]
    ]

FAGenerateGraphFromInput[input_, directed_?BooleanQ] := 
    Block [
        {fa = FAGenerateAssociation[]},
        FAExtractAndApplyTo[fa, input];
        FAGenerateGraph[fa, directed]
    ]

    (* This does everything and outputs an association with all common functions *)
FAFindAllCommon[input_] := 
    Block [ 
        {
            fa = FAGenerateAssociation[],
            k, g, w, m
        },
        FAExtractAndApplyTo[fa, input];
        g = FAGenerateGraph[fa, True];
        w = FAGenerateWeights[g, fa];
        k = Keys @ fa;
        m = Map[FAFindCommonWith[#, w, fa] &, k];
        AssociationThread[k, m]
    ]

(*- Preventing bad input to display the full association on functions *)
FAExtractAndApplyTo[___] := $Failed
FAGenerateGraph[___] := $Failed
FAGenerateWeights[___] := $Failed
FAFindCommonWith[___] := $Failed
FAFindAllCommon[___] := $Failed


(* --- Counting all functions in an expression --- *)

bannedSymbols = Join[mathsSymbols, systemSymbols, colorSymbols, boxesSymbols, functionSymbols, stylingSymbols, obsoleteSymbols];
mathsSymbols = {"Not","Or", "Greater", "Equal", "And", "LessEqual", "Unequal", "GreaterEqual", "Less", "Times", "Plus", "Power", "True", "False"}; 
systemSymbols = {"ImageSizeCache","RuleDelayed", "DeleteWithContents", "SelectWithContents", "Blank","Undefined", "Symbol", "Slot", "Missing", "Out", "CompoundExpression", "Integer", "Rule", "Null", "Function", "None", "Set"};
colorSymbols = {"Lighter","Red","Green","Blue","Black","White","gray","Cyan","Magenta","Yellow","Brown","Orange","Pink","Purple","LightRed","LightGreen","LigthBlue","LightCyan","LightMagenta","LightYellow","LightBrown","LightOrange","LightPink","LightPurple","Transparent","I","AlpineColors","Aquamarine","ArmyColors","AtlanticColors","AuroraColors","AvocadoColors","BeachColors","BlueGreenYellow","BrassTones","BrightBands","BrownCyanTones","CandyColors","CherryTones","CMYKColors","CoffeeTones","DarkBands","DarkRainbow","DarkTerrain","DeepSeaColors","FallColors","FruitPunchColors","FuchsiaTones","GrayTones","GrayYellowTones","GreenBrownTerrain","GreenPinkTones","IslandColors","LakeColors","LightTemperatureMap","LightTerrain","MintColors","NeonColors","Pastel","PearlColors","PigeonTones","PlumColors","Rainbow","RedBlueTones","RedGreenSplit","RoseColors","RustTones","SandyTerrain","SiennaTones","SolarColors","SouthwestColors","StarryNightColors","SunsetColors","TemperatureMap","ThermometerColors","ValentineTones","WatermelonColors"};
boxesSymbols = {"DynamicModuleBox", "DynamicBox", "NamespaceBox", "FractionBox","RowBox","BoxData","ErrorBox", "Cell", "RawBoxes", "StyleBox", "FormBox", "SuperscriptBox", "SqrtBox", "TemplateBox","AdjustmentBox","ButtonBox","DisplayForm","ErrorBox","FormBox","FrameBox","GridBox","InterpretationBox","ListPickerBox","OverscriptBox","RadicalBox","RowBox","SqrtBox","SubscriptBox","SubsuperscriptBox","SuperscriptBox","TagBox","TemplateBox","UnderoverscriptBox","UnderscriptBox"};
functionSymbols = {"ToBoxes","WolframLanguageData", "HoldComplete", "List", "Evaluate", "Show", "Composition"};
stylingSymbols = {"StandardForm", "Medium", "Axis", "GrayLevel", "Subscript", "Left", "Right", "Bottom"};
obsoleteSymbols = {"SequenceForm"};


exceptions = Alternatives @@ Names["System`*"];

FCCounter[input___, head_String] := 
    KeyDrop[
        Counts[
            Cases[input, 
                s_Symbol /; MatchQ[
                    SymbolName[Unevaluated[s]],
                    exceptions]
                    :> 
                    SymbolName[Unevaluated[s]]
                    ,
                {0, Infinity},
                Heads->True
                ]
        ],
        Append[bannedSymbols,head]
    ]

FCCounterNoOptions[input___, head_String] := 
    Module[
        {tmp = Counts[
            Cases[input, 
                s_Symbol /; MatchQ[
                    SymbolName[Unevaluated[s]],
                    exceptions]
                    :> 
                    SymbolName[Unevaluated[s]]
                    ,
                {0, Infinity},
                Heads->True
                ]
            ]},
        If[SameQ[input, "MISSING"],
            <||>,
            KeyDrop[
                tmp,
                Join[Append[bannedSymbols, head],
                Select[Keys @ tmp, DPOptionQ[#] && Not[DPIsOptionOfQ[head, #]] &]
               ]
            ]
        ]
    ]

FCFrequencyList[functions_List, level_String] := 
    Join @@ ParallelMap[
        <| # -> FCCounterNoOptions[DPConvertDoc[#, level], #] |> &, 
        functions
    ]
    
FCGenerateGraph[association_Association, directed_?BooleanQ] := 
    Block [
        {
            k = Keys @ association,
            v
        },
        v = Values @ Map[Lookup[#, k, 0] &, association];
        AdjacencyGraph[k, v, DirectedEdges->directed]
    ]

FCGenerateWeights[g_Graph, association_Association] := FAGenerateWeights[g, association, WeightFunction]
FCGenerateWeights[g_Graph, association_Association, formula_] := FAGenerateWeights[g,association]


FCFindCommonWith[func_String, weights_, association_Association] :=
	Block [ 
		{
			w = Map[association[func][[#]] * weights[#] &, Keys @ association[func]]
		},
		AssociationThread [
			Keys @ association[func],
			w
		]
    ] 
    
(* --- Documentation Parser ---*)

DPConvertDoc[doc_List] := 
    Check [
        (doc // ToBoxes // MakeExpression) 
            /. ExpressionCell[a_, __] :> a,
        $Failed
    ]

DPConvertDoc[funcName_String, level_String]:= 
    Block [
        {tmp = WolframLanguageData[funcName, "DocumentationExampleInputs"]},
        If [MissingQ[tmp], 
            "MISSING",
            tmp = DPConvertDoc[Flatten @ Lookup[tmp, level, {}]];
            If [FailureQ[tmp],
                "MISSING",
                tmp
            ]
        ]
    ]

optionList := optionList = 
    Pick[
        WolframLanguageData[All, "Name"],
        StringContainsQ[WolframLanguageData[All, "PlaintextUsage"], "is an option"]
    ];

DPOptionQ[function_String] := MemberQ[optionList, function]
DPIsOptionOfQ[funtion_String, option_String] := MemberQ[Keys @ WolframLanguageData[function, "Options"], option]


End[]



EndPackage[]